#include<iostream>
#include<iomanip>
#include "constans.h"
#include"template_functions.h" // содержит определение моих шаблонных функций

// декларация функции main
auto main () -> int;

// деклорация фунуции Type_Thecking
auto Type_Thecking (char c) -> char;

// деклорация функции вывода адреса функции main
auto addressfunctions (int (&func)(), const char *str) -> void;

// деклорация функции для вывода адреса функции Type_Thecking
auto addressfunctions (char (&func)(char), const char *str) -> void;

// создаём переменную в статической памяти в секции .bss
short staVal;

// создаём переменную в статической памяти в секции .data
short size{5};

// создаём массив типа short из пяти элементов в статической памяти
short statArray[]{5, 66, 74, 20, 10};

// деклорация функции вывода адреса переменной, адреса и значения элементов массива созданных в стеке
auto stecFunc () -> void;

// деклорация функции вывода адреса переменной и адреса и значения элементов массива созданных в куче
auto heapFunc () -> RetConst;

// функция для задания №1
auto Task_1 () -> void {
    std::string s = "Задание 1)";
    std::cout << std::setw(30) << std::right << s << '\n';
    std::cout << "Выведите следующее:\n"
                 "адрес функции main\n"
                 "адрес функции (создайте функцию с любой сигнатурой)\n"
                 "адрес переменной созданной в стэке\n"
                 "aдpecа и значения элементов массива созданного в стэке (выведите в цикле)\n"
                 "адрес переменной в статической памяти в секции .bss\n"
                 "адрес переменной в статической памяти в секции .data\n"
                 "адpecа и значения элементов массива созданного в статической памяти (выведите в цикле)\n"
                 "адрес переменной созданной в куче\n"
                 "aдpecа и значения элементов массива созданного в куче (выведите в цикле)\n" << std::endl;

    // вызов функции для вывода адреса функции main
    addressfunctions (main, "Вывод адреса функции main: ");

    // вызов функции для вывода адреса функции Type_Thecking
    addressfunctions (Type_Thecking, "Вывод адреса функции  Type_Thecking: ");

    // вызов функции вывода адреса переменной, адреса и значения элементов массива созданных в стеке
    stecFunc ();

    // вызов функции вывода адреса переменной, адреса и значения элементов массива созданных в куче
    heapFunc ();
}

// функция вывода адреса переменной, адреса и значения элементов массива созданных в стеке
auto stecFunc () -> void {
    // создаём переменную для длины массива и вывода адреса  переменной созданной в стеке
    constexpr short arrSize{5};
    std::cout << "\vВывод адреса переменной arrSize созданной в стэке: " << &arrSize << '\n';
    // создаём массив типа short из пяти элементов в стеке
    short stecArray[arrSize];
    // функция для заполнения массива вихрем Мерсена
    MersWhir (stecArray, arrSize);
    // вызов функции для вывода адреса и значений элементов массива созданного в стеке
    ArrayPrint (stecArray, arrSize, "\vВывод aдpecа и значения элементов массива stecArray"
                                   " созданного в стэке (выводим в цикле)");

    // вывод адреса переменной staVal в статической памяти в секции .bss
    std::cout << "\vВывод адреса переменной staVal"
                 " в статической памяти в секции .bss " << &staVal << '\n';

    // вывод адреса переменной size в статической памяти в секции .data
    std::cout << "\vвывод адреса переменной size"
                 " в статической памяти в секции .data " << &size << '\n';


    // вызов функции для вывода адреса и значений элементов массива созданного в статической памяти
    ArrayPrint (statArray, ::size, "\vВывод aдpecа и значения элементов массива statArray"
                                  " созданного в статической памяти (выводим в цикле)");
}


// функция вывода адреса переменной, адреса и значения элементов массива созданных в куче
auto heapFunc () -> RetConst {
    // запрос на выделение динамической памяти для целочисленного значения
    short *dinamValue = new (std::nothrow) short{10};
    if ( ! dinamValue) { // обрабатываем случай, когда new возвращает null (т.е. память не выделяется)
        // Обработка этого случая
        std::cout << "память не выделенна!!!";
        return ErrMemory;
    }
    else {
        std::cout <<  "\vВывод адреса переменной dinamValue созданной в куче: " << &dinamValue << '\n';
        delete dinamValue; // освобождаем память
        dinamValue = nullptr; // обнуляем указатель
    }

    // запрос на выделение динамической памяти для массива
    short *dinamArray = new (std::nothrow) short[::size];
    if ( ! dinamArray) { // обрабатываем случай, когда new возвращает null (т.е. память не выделяется)
        // Обработка этого случая
        std::cout << "память не выделенна!!!";
        return ErrMemory;
    }
    else {
        // функция для заполнения массива вихрем Мерсена
        MersWhir (dinamArray, size);
        // вызов функции дли вывода массива
        ArrayPrint (dinamArray, size, "\vВывод aдpecа и значения элементов массива dinamArray"
                                     " созданного в куче (выводим в цикле)");
        delete[] dinamArray; // освобождаем память
        dinamArray = nullptr; // обнуляем указатель
    }
    return Ok;
}

// функция вывода адреса функции Type_Thecking
auto addressfunctions (char (&func)(char c), const char *str) -> void {

    std::cout << str << reinterpret_cast<void*>(func) << '\n';
}

// функция вывода адреса функции main
auto addressfunctions (int (&func)(), const char *str) -> void {

    std::cout << str << reinterpret_cast<void*>(func) << '\n';
}
